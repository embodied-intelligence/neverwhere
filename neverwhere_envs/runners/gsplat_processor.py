import os
import typing
from collections import OrderedDict
from dataclasses import dataclass
from typing import Literal, Optional, Tuple
from io import BytesIO

import numpy as np
import torch
import open3d as o3d
from neverwhere_envs.utils.colmap import Parser
from plyfile import PlyData


@dataclass
class Config:
    """Configuration for GSplatProcessor"""
    
    # Path to the checkpoint file (.pt)
    ckpt_path: str = ""
    # Color mode for PLY export
    ply_color_mode: Literal["sh_coeffs", "rgb"] = "sh_coeffs"
    # Optional oriented bounding box parameters
    obb_center: Optional[Tuple[float, float, float]] = None
    obb_rotation: Optional[Tuple[float, float, float]] = None  
    obb_scale: Optional[Tuple[float, float, float]] = None


class GSplatProcessor:
    """Processor for exporting 3D Gaussian Splatting models"""

    @staticmethod
    def write_ply(
        filename: str,
        count: int,
        map_to_tensors: typing.OrderedDict[str, np.ndarray],
    ):
        """
        Write PLY file with vertex properties.
        
        Args:
            filename: Output PLY filename
            count: Number of vertices to write
            map_to_tensors: OrderedDict mapping property names to numpy arrays
        """
        # Validate inputs
        if not all(tensor.size == count for tensor in map_to_tensors.values()):
            raise ValueError("Count does not match length of all tensors")

        if not all(
            isinstance(tensor, np.ndarray)
            and (tensor.dtype.kind == "f" or tensor.dtype == np.uint8)
            and tensor.size > 0
            for tensor in map_to_tensors.values()
        ):
            raise ValueError("All tensors must be numpy arrays of float or uint8 type and not empty")

        with open(filename, "wb") as ply_file:
            # Write header
            ply_file.write(b"ply\n")
            ply_file.write(b"format binary_little_endian 1.0\n")
            ply_file.write(b"comment Generated by Neverwhere\n")
            ply_file.write(b"comment Vertical Axis: z\n")
            ply_file.write(f"element vertex {count}\n".encode())

            # Write properties
            for key, tensor in map_to_tensors.items():
                data_type = "float" if tensor.dtype.kind == "f" else "uchar"
                ply_file.write(f"property {data_type} {key}\n".encode())

            ply_file.write(b"end_header\n")

            # Write binary data
            for i in range(count):
                for tensor in map_to_tensors.values():
                    value = tensor[i]
                    if tensor.dtype.kind == "f":
                        ply_file.write(np.float32(value).tobytes())
                    elif tensor.dtype == np.uint8:
                        ply_file.write(value.tobytes())

    def __init__(self, cfg: Config):
        self.cfg = cfg
        
        # Load checkpoint
        self.ckpt = torch.load(cfg.ckpt_path, map_location="cuda:0")
        self.splats = self.ckpt["splats"]

    def export_ply(self, output_filename: str = "model.ply"):
        """Export Gaussian splats to PLY file"""
        
        # Skip if output file already exists
        if os.path.exists(output_filename):
            print(f"Output file {output_filename} already exists, skipping export")
            return
        
        map_to_tensors = OrderedDict()
        
        with torch.no_grad():
            positions = self.splats["means"].cpu().numpy()
            count = positions.shape[0]
            n = count
            map_to_tensors["x"] = positions[:, 0]
            map_to_tensors["y"] = positions[:, 1] 
            map_to_tensors["z"] = positions[:, 2]
            map_to_tensors["nx"] = np.zeros(n, dtype=np.float32)
            map_to_tensors["ny"] = np.zeros(n, dtype=np.float32)
            map_to_tensors["nz"] = np.zeros(n, dtype=np.float32)

            if self.cfg.ply_color_mode == "rgb":
                sh0 = self.splats["sh0"]
                colors = torch.clamp(sh0[:, 0], 0.0, 1.0).cpu().numpy()
                colors = (colors * 255).astype(np.uint8)
                map_to_tensors["red"] = colors[:, 0]
                map_to_tensors["green"] = colors[:, 1]
                map_to_tensors["blue"] = colors[:, 2]
            elif self.cfg.ply_color_mode == "sh_coeffs":
                sh0 = self.splats["sh0"].contiguous().cpu().numpy()
                shN = self.splats["shN"].contiguous().cpu().numpy()
                for i in range(sh0.shape[2]):
                    map_to_tensors[f"f_dc_{i}"] = sh0[:, 0, i, None]
                shN = shN.reshape((n, -1))
                for i in range(shN.shape[1]):
                    map_to_tensors[f"f_rest_{i}"] = shN[:, i]

            map_to_tensors["opacity"] = self.splats["opacities"].data.cpu().numpy()

            scales = self.splats["scales"].data.cpu().numpy()
            for i in range(3):
                map_to_tensors[f"scale_{i}"] = scales[:, i, None]

            quats = self.splats["quats"].data.cpu().numpy()
            for i in range(4):
                map_to_tensors[f"rot_{i}"] = quats[:, i, None]

            if all(x is not None for x in [self.cfg.obb_center, self.cfg.obb_rotation, self.cfg.obb_scale]):
                # TODO: Implement OBB filtering if needed
                pass

            # filter invalid values
            select = np.ones(n, dtype=bool)
            for k, t in map_to_tensors.items():
                select = np.logical_and(select, np.isfinite(t).all(axis=-1))
            
            # filter gaussians that have opacities < 1/255, because they are skipped in cuda rasterization
            low_opacity_gaussians = (map_to_tensors["opacity"]) < -5.5373
            select[low_opacity_gaussians] = 0
            
            if np.sum(select) < n:
                print(f"Filtered {n - np.sum(select)} invalid/low-opacity Gaussians")
                for k, t in map_to_tensors.items():
                    map_to_tensors[k] = map_to_tensors[k][select]
                count = np.sum(select)

        os.makedirs(os.path.dirname(output_filename), exist_ok=True)
        self.write_ply(output_filename, count, map_to_tensors)
        print(f"Exported {count} Gaussians to {output_filename}")

    def export_splat(self, ply_path: str, output_filename: str = "model.splat"):
        """
        Export Gaussian splats to .splat format from PLY file
        
        Args:
            ply_path: Path to input PLY file
            output_filename: Path to output .splat file
        """
        if os.path.exists(output_filename):
            print(f"Output file {output_filename} already exists, skipping export")
            return
        
        def process_ply_to_splat(ply_file_path: str):
            plydata = PlyData.read(ply_file_path)
            vert = plydata["vertex"]
            sorted_indices = np.argsort(
                -np.exp(vert["scale_0"] + vert["scale_1"] + vert["scale_2"])
                / (1 + np.exp(-vert["opacity"]))
            )
            buffer = BytesIO()
            for idx in sorted_indices:
                v = plydata["vertex"][idx]
                position = np.array([v["x"], v["y"], v["z"]], dtype=np.float32)
                scales = np.exp(
                    np.array(
                        [v["scale_0"], v["scale_1"], v["scale_2"]],
                        dtype=np.float32,
                    )
                )
                rot = np.array(
                    [v["rot_0"], v["rot_1"], v["rot_2"], v["rot_3"]],
                    dtype=np.float32,
                )
                SH_C0 = 0.28209479177387814
                color = np.array(
                    [
                        0.5 + SH_C0 * v["f_dc_0"],
                        0.5 + SH_C0 * v["f_dc_1"],
                        0.5 + SH_C0 * v["f_dc_2"],
                        1 / (1 + np.exp(-v["opacity"])),
                    ]
                )
                buffer.write(position.tobytes())
                buffer.write(scales.tobytes())
                buffer.write((color * 255).clip(0, 255).astype(np.uint8).tobytes())
                buffer.write(
                    ((rot / np.linalg.norm(rot)) * 128 + 128)
                    .clip(0, 255)
                    .astype(np.uint8)
                    .tobytes()
                )
            return buffer.getvalue()
        
        splat_data = process_ply_to_splat(ply_path)
        with open(output_filename, "wb") as f:
            f.write(splat_data)
            
        print(f"Exported splat file to {output_filename}")


def main(ckpt_path: str, gsplat_dir: str, ply_path: str = "model.ply", splat_path: str = "model.splat", **kwargs):
    """
    Export 3D Gaussian Splatting model to PLY and splat formats
    
    Args:
        ckpt_path: Path to checkpoint file
        ply_path: Path to output PLY file
        splat_path: Path to output splat file
        **kwargs: Additional config parameters
    """
    cfg = Config(
        ckpt_path=ckpt_path,
        **kwargs
    )
    ply_path = os.path.join(gsplat_dir, ply_path)
    splat_path = os.path.join(gsplat_dir, splat_path)
    
    processor = GSplatProcessor(cfg)
    processor.export_ply(ply_path)
    processor.export_splat(ply_path, splat_path)